---
trigger: always_on
---

Https://youtu.be/dzO0yX4MRLM請你參考這個網址，看看這個代碼有沒有修改的空間

1.使用「表驅動法 (Table-Driven Methods)」
原理：凡是可以透過邏輯語句（如 if-else 或 switch）來選擇的事物，通常都可以改用查表的方式解決。
優點：隨著選項變多，維護一個表格（Map 或陣列）比維護一長串的邏輯判斷更簡單直觀。
範例：影片中舉例計算每個月的天數，若需考慮閏年，只需為數據表增加一個維度即可 。

2.運用「衛語句 (Guard Clauses)」與「早返回 (Early Return)」
原理：這是「防禦性編程」的一種體現。先處理異常狀況或邊界條件，一旦不符合就直接 return 或退出，而不是將主要的業務邏輯包裹在深層的 else 區塊中。
效果：避免代碼變成「漏斗型」的深層縮排，簡化複雜參數的驗證邏輯。
技巧：記得要顛倒原本的判斷邏輯（例如把 if (valid) { do work } 改成 if (!valid) return; do work）

3.提取獨立函數 (Extract Method) 
原理：將參數驗證或複雜的邏輯提取出來，成為一個獨立的函數。
優點：讓主函數的功能更加聚焦，邏輯更清晰。
利用「多態 (Polymorphism)」取代分支
原理：物件導向中的多態調用，在邏輯上類似於 switch 分支，但能完美隱藏分支邏輯。
搭配模式：結合「簡單工廠模式」，將分支邏輯分離並獨立出來。

4.使用「狀態模式 (State Pattern)」解決複雜狀態機
場景：當物件有多種狀態且狀態間的操作會相互影響時（影片舉了微波爐的例子：加熱中、開門、關門等狀態）。
做法：將每個狀態對應的操作封裝在一起，利用多態來選擇相應的狀態，從而徹底消除判斷狀態的條件語句。

5.使用「高級函數 (Higher-Order Functions)」處理集合
原理：資料處理邏輯通常是篩選、排序、分組或轉換。
做法：使用主流語言提供的 filter, map, reduce 等高級函數來取代巢狀的 for 迴圈與 if 判斷。
優點：利用鍊式調用 (Chaining) 讓代碼更流暢，瞬間消除多層巢狀。

6.使用語法糖處理空值 (Null Safety) 
做法：利用現代語言（如 TypeScript, Kotlin, C# 等）提供的空合併運算符（如 ??）或可選鏈（Optional Chaining, 如 ?.），優雅地處理空物件判斷，避免寫入大量的 if (obj != null)。

7.深度檢查一下，程式中，那些可以使用多線程並發 (Multithreading)或多進程並行 (Multiprocessing)